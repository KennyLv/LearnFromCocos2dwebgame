逆波兰表达式

逆波兰表达式又叫做后缀表达式。在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，所以，这种表示法也称为中缀表示。
波兰逻辑学家 J.Lukasiewicz于1929年提出了另一种表示表达式的方法。按此方法，每一运算符都置于其运算对象之后，故称为后缀表示。
逆波兰表达式
　　逆波兰表达式，它的语法规定，表达式必须以逆波兰表达式的方式给出。逆波兰表达式又叫做后缀表达式。
		这个知识点在数据结构和编译原理这两门课程中都有介绍，下面是一些例子：
　　		  正常的表达式--->逆波兰表达式
　　		  a+b ---> a,b,+
　　		  a+(b-c) ---> a,b,c,-,+
　　		  a+(b-c)*d ---> a,b,c,-,d,*,+
　　		  a+d*(b-c)--->a,d,b,c,-,*,+
　　		  a=1+3 ---> a=1,3 +
　　		  http=(smtp+http+telnet)/1024 ---> http=smtp,http,telnet,+,+,1024,/

逆波兰表达式的用途
　　逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)*(c+d)转换为ab+cd+*

逆波兰表达式的优势
　　它的优势在于只用两种简单操作，入栈和出栈就可以搞定任何普通表达式的运算。其运算方式如下：
　　如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，
		最后当表达式扫描完后，栈里的就是结果。


一般算法
　　将一个普通的中序表达式转换为逆波兰表达式的一般算法是：
　　(1)首先构造一个运算符栈，此运算符在栈内遵循越往栈顶优先级越高的原则。
　　(2)读入一个用中缀表示的简单算术表达式，为方便起见,设该简单算术表达式的右端多加上了优先级最低的特殊符号“#”。
　　(3)从左至右扫描该算术表达式，从第一个字符开始判断，如果该字符是数字，则分析到该数字串的结束并将该数字串直接输出。
　　(4)如果不是数字，该字符则是运算符，此时需比较优先关系。
　　		做法如下：将该字符与运算符栈顶的运算符的优先关系相比较。如果，该字符优先关系高于此运算符栈顶的运算符，则将该运算符入栈。倘若不是的话，则将栈顶的运算符从栈中弹出，直到栈顶运算符的优先级低于当前运算符，将该字符入栈。
　　(5)重复上述操作(3)-(4)直至扫描完整个简单算术表达式，确定所有字符都得到正确处理，我们便可以将中缀式表示的简单算术表达式转化为逆波兰表示的简单算术表达式。

算法流程
　　下面是程序化算法流程：
　　1、建立运算符栈stackOperator用于运算符的存储，压入'/0'。
　　2、预处理表达式，正、负号前加0(如果一个加号（减号）出现在最前面或左括号后面，则该加号（减号）为正负号) 。
　　3、顺序扫描表达式，如果当前字符是数字（优先级为0的符号），则直接输出该数字；如果当前字符为运算符或括号（优先级不为0的符号），则判断第4点 。
　　4、若当前运算符为'('，直接入栈；
	　　若为')'，出栈并顺序输出运算符直到遇到第一个'('，遇到的第一个'('出栈但不输出；
　　	  若为其它，比较stackOperator栈顶元素与当前元素的优先级：
　　               如果 栈顶元素运算符优先级 >= 当前元素的优先级，出栈并顺序输出运算符直到 栈顶元素优先级 < 当前元素优先级，然后当前元素入栈；
　　               如果 栈顶元素 < 当前元素，直接入栈。
　　5、重复第3点直到表达式扫描完毕。
　　6、顺序出栈并输出运算符直到栈顶元素为'/0'。
　　int Precedence(char sign)
　　{
　　	  switch(sign)
　　	  {
　　		  case '+':
　　		  case '-':
　　		  return 1;
　　		  case '*':
　　		  case '/':
　　		  return 2;
　　		  case '^':
　　		  case '%':
　　		  return 3;
　　		  case '(':
　　		  case '@':
　　		  default:
　　		  return 0;
　　	  }
　　}
　　/****************中缀表达式转换成后缀表达式 ********************/
　　void Change(char* s1,char* s2)
　　{
　　	  seqstack T;
　　	  int i=0,j=0;
　　	  char ch;
　　	  SetNull(&T);
　　	  Push(&T,'@');
　　	  ch=s1[i];
　　	  while(ch!='\0')
　　	  {
　　		  if(ch==' ')
　　			ch=s1[++i];
　　		  else if(ch=='(')
　　		  {
　　			  Push(&T,ch);
　　			  ch=s1[++i];
　　		  }
　　		  else if(ch==')')
　　		  {
　　			  while(GetTop(&T)!='(')
　　			  s2[j++]=Pop(&T);
　　			  Pop(&T);
　　			  ch=s1[++i];
　　		  }
　　		  else if(ch=='+' || ch=='-' ||ch=='*' ||ch=='/' ||ch=='^' ||ch=='%')
　　		  {
　　			  char w=GetTop(&T);
　　			  while(Precedence(w)>=Precedence(ch))
　　			  {
　　				  s2[j++]=w;
　　				  Pop(&T);
　　				  w=GetTop(&T);
　　			  }
　　			  Push(&T,ch);
　　			  ch=s1[++i];
　　		  }
　　		  else
　　		  {
　　			  while((ch>='0' && ch<='9')||ch=='.')
　　			  {
　　				  s2[j++]=ch;
　　				  ch=s1[++i];
　　			  }
　　			  s2[j++]=' ';
　　		  }
　　	  }
　　	  ch=Pop(&T);
　　	  while(ch!='@')
　　	  {
　　		  s2[j++]=ch;
　　		  ch=Pop(&T);
　　	  }
　　	  s2[j++]='\0';
　　}

优先级分类
　　优先级分为栈内优先级isp(In stack priority)和栈外优先级icp(In coming priority)。除了括号以外，其他运算符进栈后优先级都升1，这样可以体现在中缀表达式中相同优先级的操作符自左向右计算的要求，让位于栈顶的操作符先退栈并输出。
　　各运算符及符号优先级：
　　
操作符	#	^	*,/,%	+,- 	(	)
isp	0	7	5	3	1	8
icp	0	6	4	2	8	1

扩展阅读：
          http://www.cnblogs.com/chinadhf/archive/2006/07/16/452137.html
		   http://blog.163.com/terrorist_1992@126/blog/static/104676822200931185652540
参考程序：http://blog.163.com/terrorist_1992@126/blog/static/104676822200931185652540